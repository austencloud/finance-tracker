// src/lib/services/ai/conversation/conversationService.ts

import { get } from 'svelte/store';
import { v4 as uuidv4 } from 'uuid';

// Central application store
import { appStore } from '$lib/stores/AppStore';
import type { Transaction } from '$lib/stores/types';

// AI Client and utilities
import { deepseekChat, getFallbackResponse, DeepSeekApiError } from '../deepseek-client';
import { getSystemPrompt, getSummaryPrompt } from '../prompts';
import { textLooksLikeTransaction, formatCurrency as formatCurrencyUtil } from '$lib/utils/helpers';
import { BULK_DATA_THRESHOLD_LENGTH } from './constants'; // Assuming this constant exists

// Import ALL handlers that participate in the chat flow
import { handleMood } from './handlers/handleMood';
import { handleDirectionClarification } from './handlers/handleDirectionClarification';
// import { handleCorrectionClarification } from './handlers/handleCorrectionClarification'; // Add when created
import { handleCountCorrection } from './handlers/handleCountCorrection';
import { handleBulkDirectionCorrection } from './handlers/handleBulkDirectionCorrection';
import { handleFillDetails } from './handlers/handleFillDetails';
import { handleCorrection } from './handlers/handleCorrection';
import { handleInitialData } from './handlers/handleInitialData'; // Now part of the main chain
import { handleExtraction } from './handlers/handleExtraction';
import { handleNormalResponse } from './handlers/handleNormalResponse';
// import { handleBulkData } from './handlers/handleBulkData'; // Not used in this specific sendMessage flow
// import { handleDuplicateConfirmation } from './handlers/handleDuplicateConfirmation'; // Add when needed

// Regex for detecting bulk direction commands easily
const BULK_DIRECTION_ALL_IN_REGEX = /\b(all|these are all|mark all as)\s+(in|income|deposits?)\b/i;
const BULK_DIRECTION_ALL_OUT_REGEX =
    /\b(all|these are all|mark all as)\s+(out|expenses?|payments?|spending)\b/i;

/**
 * Sets the initial processing state when a message is sent.
 * @param message - The user's input message.
 */
function startProcessing(message: string): void {
    // Add user message to the conversation history
    appStore.addConversationMessage('user', message);
    // Set the global processing flag and initial status/progress
    appStore.setConversationProcessing(true);
    appStore.setConversationStatus('Thinking...', 10);
}

/**
 * Finalizes processing, adds the assistant's response, and resets state.
 * @param assistantResponse - The response string generated by the handlers or error handler.
 */
function finishProcessing(assistantResponse: string): void {
    // Trim the response and ensure it's not null/undefined
    let finalResponse = assistantResponse?.trim() || '';

    // Add the assistant's response to the conversation history if it's not empty
    if (finalResponse) {
        appStore.addConversationMessage('assistant', finalResponse);
    } else {
        // Log if no response was generated (might indicate an issue if one was expected)
        console.warn('[finishProcessing] No assistant response content provided.');
    }

    // Update status to 'Finished' temporarily
    appStore.setConversationStatus('Finished', 100);

    // After a short delay, clear the processing flag and status/progress
    setTimeout(() => {
        appStore.setConversationProcessing(false);
        // Only clear status if it's still 'Finished' (might have been set to Error)
        if (get(appStore).conversation.status === 'Finished') {
            appStore.setConversationStatus('', 0);
        }
    }, 300); // 300ms delay
}

/**
 * Handles errors caught during message processing.
 * @param error - The error object.
 * @returns A user-friendly error message string.
 */
function handleProcessingError(error: unknown): string {
    console.error('[Processing error]:', error);

    // Set status to indicate an error occurred
    appStore.setConversationStatus('Error');

    let message = "I'm having trouble processing that...";

    // Provide more specific messages for known API errors
    if (error instanceof DeepSeekApiError) {
        if (error.status === 401 || error.message.includes('Authentication')) {
            message = "Can't connect to AI services (authentication issue). Please check your API key configuration.";
        } else if (error.status === 429 || error.message.includes('rate limit')) {
            message = "The AI service is busy (rate limit reached). Please try again in a moment.";
        } else if (error.status === 500 || error.message.includes('service is experiencing issues')) {
            message = "The AI service seems to be having temporary issues. Please try again later.";
        } else {
            // General API error
            message = `Sorry, there was an API error (${error.status || 'network'}): ${error.message}`;
        }
    } else if (error instanceof Error) {
        // General JavaScript error
        message = `An unexpected error occurred: ${error.message}`;
    } else {
        // Unknown error type
        message = `An unknown error occurred during processing.`;
    }
    return message;
}

/**
 * Main function to process user messages, orchestrating various handlers.
 * @param message - The user's input message string.
 */
export async function sendMessage(message: string): Promise<void> {
    message = message.trim();
    // Ignore empty messages
    if (!message) return;

    // Prevent concurrent processing
    if (get(appStore).conversation.isProcessing) {
        appStore.addConversationMessage('assistant', `I'm still working on the previous request. Please wait.`);
        return;
    }

    // Set initial processing state and add user message to history
    startProcessing(message);

    // --- Determine explicit direction intent (e.g., "mark all as income") ---
    let explicitDirectionIntent: 'in' | 'out' | null = null;
    const lowerMessage = message.toLowerCase();
    if (BULK_DIRECTION_ALL_IN_REGEX.test(lowerMessage) && message.length < 50) {
        explicitDirectionIntent = 'in';
    } else if (BULK_DIRECTION_ALL_OUT_REGEX.test(lowerMessage) && message.length < 50) {
        explicitDirectionIntent = 'out';
    }
    // --- End direction intent ---

    let handled = false;
    let assistantResponse = '';

    try {
        // --- Define the ORDERED array of handlers ---
        // Order matters: More specific handlers or those checking state flags run first.
        const handlers = [
            // State-based / Specific Intent Handlers
            handleMood,                     // Simple greetings, thanks, okays
            handleDirectionClarification,   // Handles response if waiting for direction flag
            // handleCorrectionClarification, // Handles response if waiting for correction target (Add Later)
            // handleDuplicateConfirmation,  // Handles response if waiting for duplicate confirmation (Add Later)
            handleCountCorrection,          // Handles "you missed one", requires context
            handleBulkDirectionCorrection,  // Handles "mark all as expense"
            handleFillDetails,              // Handles "categorize this", requires context? (placeholder)
            handleCorrection,               // Handles "change amount to X", requires context

            // Data Extraction Handlers
            handleInitialData,              // Handles first TXN input, checks history/state
            handleExtraction,               // Handles subsequent TXN input

            // Fallback Handler
            handleNormalResponse           // General conversation if nothing else matches
        ];
        // --- END Handler Array ---

        // --- Iterate through handlers ---
        for (const handler of handlers) {
            // Pass message and intent to each handler
            // Handler function signature: (message: string, explicitDirectionIntent: 'in' | 'out' | null) => Promise<{ handled: boolean; response?: string }>
            const result = await handler(message, explicitDirectionIntent);

            // Check if the handler indicated it handled the message
            if (result?.handled) {
                // Get the response message, default to empty if none provided
                // An empty response means the handler added messages directly (e.g., handleMood)
                assistantResponse = result.response ?? ''; // Use nullish coalescing
                handled = true;
                console.log(`[sendMessage] Message handled by: ${handler.name}`);
                break; // Exit loop once handled
            }
        }
        // --- End Handler Loop ---

        // If loop completes and handled is still false, something unexpected happened.
        // This should ideally not occur if handleNormalResponse is the last handler.
        if (!handled) {
             console.error(`[sendMessage] Message fell through ALL handlers unexpectedly: "${message}". This indicates a logic error in the handler chain.`);
             // Provide a generic error response
             assistantResponse = "Sorry, I encountered an unexpected issue processing that message. Please try rephrasing.";
             handled = true; // Mark as handled to proceed to finally
        }

    } catch (error) {
        // Catch errors thrown from within handlers or the service itself
        assistantResponse = handleProcessingError(error);
        handled = true; // Ensure we proceed to finally
    } finally {
        // Finalize processing: Adds assistantResponse (if any) and resets processing state.
        // This runs regardless of success or failure within the try block.
        finishProcessing(assistantResponse);
    }
}

/**
 * Generates a summary of transactions using the LLM.
 */
export async function generateSummary(): Promise<void> {
    if (get(appStore).conversation.isProcessing) {
        appStore.addConversationMessage('assistant', 'Please wait until the current processing is finished.');
        return;
    }

    const txns = get(appStore).transactions;
    if (txns.length === 0) {
        appStore.addConversationMessage('assistant', `No transactions recorded yet to summarize.`);
        return;
    }

    appStore.setConversationProcessing(true);
    appStore.setConversationStatus('Generating summary...', 50);

    let summaryResponse = '';
    const today = new Date().toISOString().split('T')[0];

    try {
        const promptContent = getSummaryPrompt(txns); // Assumes getSummaryPrompt formats data correctly
        const messages = [
            { role: 'system', content: getSystemPrompt(today) },
            { role: 'user', content: promptContent }
        ];
        summaryResponse = await deepseekChat(messages, { temperature: 0.5 });

        // Fallback if LLM gives empty response
        if (!summaryResponse?.trim()) {
            const income = txns.filter(t => t.direction === 'in').reduce((sum, t) => sum + (t.amount || 0), 0);
            const expense = txns.filter(t => t.direction === 'out').reduce((sum, t) => sum + (t.amount || 0), 0);
            summaryResponse = `Summary based on ${txns.length} recorded transactions: Total Income: ${formatCurrencyUtil(income)}, Total Expenses: ${formatCurrencyUtil(expense)}.`;
        }
    } catch (error) {
        console.error('[generateSummary] LLM error:', error);
        appStore.setConversationStatus('Error generating summary');
        summaryResponse = 'There was an error generating the summary.';
    } finally {
        // Use finishProcessing to add the response and reset state
        finishProcessing(summaryResponse);
    }
}

/**
 * Aborts current processing (if possible - currently just resets state) and clears conversation history.
 */
export function abortAndClear(): void {
    // TODO: Add actual API call cancellation if deepseek-client supports AbortController signals passing
    console.log('[abortAndClear] Clearing conversation and resetting state.');
    appStore.resetConversation(); // Resets messages, status, progress, flags
    appStore.setConversationProcessing(false); // Ensure processing is marked as false
}

/**
 * Initializes the conversation state, typically on component mount.
 */
export function initialize(): void {
    console.log('[initialize] Resetting conversation state.');
    appStore.resetConversation(); // Resets to initial state
}
